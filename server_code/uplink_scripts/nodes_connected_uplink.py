"""
Nodes Connected Uplink Module
Author: JW
Date: 07/26/2023
Module Name: nodes_connected_uplink.py

Description:
The "nodes_connected_uplink.py" module provides functionalities for managing and monitoring camera nodes connected within a network. 
It interacts with a MySQL database using custom SQL utilities to add, update, and remove camera nodes, 
as well as retrieve information about connected nodes and their assignments.

Key Functions:

1. `NetstatParser`: A class that fetches the network status using the `netstat` command, 
    extracts relevant information about connected ports, and provides methods for parsing and extracting local addresses.

2. `get_node_pos(node_pos_int: int) -> str`: Returns the position of a camera node as a string ('left', 'right') based on an integer input.

3. `check_nodes_connected(gin_query: str) -> List[Dict]`: Checks and retrieves a list of connected camera nodes based on a specified gin query. It provides information about the nodes, including their gin assignment and status.

4. `check_for_port_entry(port_num: int) -> bool`: Checks if a port number already exists in the database table and returns information about the node if found.

5. `add_node(node_params: str) -> bool`: Adds a camera node to the database table "CamNodes_Info" with specified parameters, such as gin name, gin stand number, and port number.

6. `update_node(node_params: str) -> bool`: Updates the information of an existing camera node in the database, including its gin name and stand number.

7. `remove_node(node_params: str) -> bool`: Removes a camera node from the database based on the specified gin name, gin stand number, and port number.

8. `get_all_gins()`: Retrieves a list of all gins with VISN equipment from the database.

9. `compare_lists(list1, list2) -> bool`: Compares two lists and returns `True` if all elements in `list1` are present in `list2`, indicating access to all gins.

10. `check_if_all_gins_accessible(gins_accessible: json) -> bool`: Checks if the user has access to view "all_gins" and "unassigned" based on their accessible gins.

This module is designed to facilitate the management and monitoring of camera nodes within a network, making it easier to track node assignments and status.
"""

import re
import subprocess
from collections import namedtuple
from typing import List, Dict

#Uplink imports:
try:
    import utils.mySQL_utils as localSQL
    from utils.log_errors_utils import write_error_log, write_debug_log

# Local server imports:
except (ModuleNotFoundError) as mod_err:
    print("Trying local host imports in nodes_connected_uplink.py")
    from ..utils import mySQL_utils as localSQL
    from ..utils.log_errors_utils import write_error_log, write_debug_log


class NetstatParser:
    """
        Class Description:
            - Uses `netstat -plunt` to get a list of connected nodes 
            - Parses the results and returns the 4-digit node number
            - Class Code generated by ChatGPT

    """
    def __init__(self):
        self.output = ""

    def fetch_netstat_output(self):
        """
            Method Description:
                - called from nodes_connected_uplink.check_nodes_connected
                - Use the command `netstat -plunt` to get a list of all connected nodes
        """
        try:
            command = ['netstat', '-plunt']
            result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if result.returncode == 0:
                self.output = result.stdout
            else:
                print("Error fetching netstat output:")
                print(result.stderr)
        except Exception as e:
            print("An error occurred:", str(e))

    def extract_ports(self, port_range=(0, 65535)):
        """
            Method Decription:
                - Called from nodes_connected_uplink.check_nodes_connected
                - Extract just the ports from the `netstat -plunt` command
        """
        Port = namedtuple('Port', ['protocol', 'local_address', 'foreign_address', 'state', 'pid_program'])
        ports = []

        lines = self.output.strip().split('\n')
        for line in lines[2:]:
            parts = re.split(r'\s+', line.strip())
            if len(parts) >= 7:
                protocol = parts[0]
                local_address = parts[3]
                foreign_address = parts[4]
                state = parts[5]
                pid_program = ' '.join(parts[6:])

                local_port = int(local_address.split(':')[-1])
                if port_range[0] <= local_port <= port_range[1]:
                    ports.append(Port(protocol, local_address, foreign_address, state, pid_program))

        return ports

    def extract_local_addresses(self, ports):
        """
            Method Description:
                - Get the 4-digit port node number
        """
        local_addresses = [port.local_address for port in ports]
        return local_addresses


def get_node_pos(node_pos_int: int) -> str:
    """
        Function Description:
            - Called from nodes_connected_uplink.check_nodes_connected.
            - get string ('left', 'right') based on pos int
            - We want string for UI displying 

        Input Args:
            - node_pos_int (int) int value representing left or right

        Output Args:
            - (str): either 'left', 'right'
    """
    return 'left' if node_pos_int == 1 else 'right' if node_pos_int == 2 else None


def check_nodes_connected(gin_query: str) -> List[Dict]:
    """
        Function Description:
            - Called from anvil_uplink_router.check_nodes_connected
            - Checks which nodes are connected and retrieves information on the nodes for displaying.
            

        Input Args:
            - gin_query (str): name of gin to search for connected nodes on

        Output Args:
            - List[Dict]: returns of a list of dictionaries where each index in the list is a dictionary storing 
                information on a specific node at gin_query's gin
    """
    """ Return a list of connected notes:"""

    # Create a NetstatParser instance
    parser = NetstatParser()

    # Fetch the netstat output using the method
    parser.fetch_netstat_output()

    # Extract ports within the range 1 to 1024
    # connected_ports = parser.extract_ports(port_range=(2301, 5500))
    connected_ports = parser.extract_ports(port_range=(2301, 2399))

    # Extract local addresses from connected_ports
    local_addresses = parser.extract_local_addresses(connected_ports)

    # Setup connection to table:
    cnx = localSQL.sql_connect()

    camNode_info = []
    unassigned_nodes = []
    # Print the extracted local addresses
    for address in local_addresses:
        try:
            # Get the last four digits:
            port = address[-4:]
            print(port)
            
            # Select info from database table:
            if(gin_query == "All Gins" or gin_query == "Unassigned"):
                select_query = f"SELECT * FROM CamNodes_Info WHERE port = {port}"
            else:
                select_query = f"SELECT * FROM CamNodes_Info WHERE port = {port} AND GinName = '{gin_query}'"
                
            result = localSQL.sql_select(cnx, select_query)[0]

            # Get the nodes position in string format:
            node_pos = get_node_pos(result[-1])

            # Format entry for anvil data.table
            data_table_format_dict = {
                'gin_name': result[3],
                'gin_stand_num': result[4],
                # 'node_position': node_pos,
                'node_port_num': result[2],
                'active': result[1]
            }
            
            # create list to store all found nodes:
            camNode_info.append(data_table_format_dict)

        except (IndexError) as list_err:
            print(f"could not find info for node port {port}...")
            # NOTE: HERE pass port # to Python but leave fields blank informing gins workers node is connected but not assigned to a database

            data_table_format_dict = {
                'gin_name': 'Unassigned',
                'gin_stand_num': 'Unassigned',
                # 'node_position': 'Unassigned',
                'node_port_num': port,
                'active': 'Unassigned'
            }
            
            if(gin_query == "All Gins"):
                camNode_info.append(data_table_format_dict)
            elif(gin_query == "Unassigned"):
                unassigned_nodes.append(data_table_format_dict)

        except (Exception) as err:
            # Create error message:
            err_msg = f"Encountered error in, File: nodes_connected_uplink, Function: check_nodes_connected func. \nError: {err}"
            # Write error to error log:
            write_error_log(err_msg=err_msg)
            print(err_msg)

    # Close connection:
    localSQL.sql_closeConnection(cnx)
    if(gin_query == "Unassigned"):
        # If user wants unassigned_nodes: return list[dict] of the unassigned nodes in database
        return unassigned_nodes
    else:
        # Else, return the found nodes for `gin_query`
        return camNode_info 


def check_for_port_entry(port_num: int) -> dict: 
    """
        Function Description:
            - Called from anvil_uplink_router.check_for_node_entry
            - Access `CamNodes_Info` data-table to see if info already exists for `port_num`
            - Return data if exists.

        Input Args:
            - port_num (int): port_num of node to check if it exists 

        Output Args:
            - node_info (dict): dicionary storing info on node.
            - node_info = {
                'active': result[1],
                'port': result[2],
                'gin_name': result[3],
                'ginstand_num': result[4]
            }
    """

    # Setup connection to table:
    cnx = localSQL.sql_connect()

    try: 
        select_query = f"SELECT * FROM CamNodes_Info WHERE port = {port_num};"

        try:
            # Try to get results
            result = localSQL.sql_select(cnx, select_query)[0]

            print(f"result: {result}")
            print(f"result type: {type(result)}")
            
            # Get node info:
            node_info = {
                'active': result[1],
                'port': result[2],
                'gin_name': result[3],
                'ginstand_num': result[4]
            }

            return node_info


        except(IndexError) as ierr:
            # this section is ran if entry does not exist:
            return None

    except (Exception) as err:
        # Create error message:
        err_msg = f"Encountered error in, File: nodes_connected_uplink, Function: check_for_port_entry func. \nError: {err}"
        # Write error to error log:
        write_error_log(err_msg=err_msg)
        print(err_msg)
        return None

    finally:
        localSQL.sql_closeConnection(cnx)


import json
def add_node(node_params: json) -> bool:
    """
        Function Description:
            - Called from anvil_uplink_router.add_node_connection
            - Addes node info to database using user entered info.

        Input Args:
            - node_params (json(dict)): node parameters being written to database
            - node_params = json.dumps({
                'gin_stand': self.gin_name_drop_down.selected_value,
                'gin_stand_num': self.gin_stand_drop_down.selected_value,
                'port_num': port_num,
            })

        Output Args:
            - bool: indicates if successful update of database
    """
    """Add camera node to database table CamNodes_Info"""

    # unpack json to python dict:
    node_params = json.loads(node_params)

    # Unpack dictionary
    gin_name = node_params.get('gin_stand')
    gin_stand_num = node_params.get('gin_stand_num')
    port_num = node_params.get('port_num')

    

    # Add node to datatable:
    try:
        # Setup connection to table:
        cnx = localSQL.sql_connect()

        print(f"Adding Node {port_num} to database..")

        insert_query = f"INSERT INTO CamNodes_Info (Active, port, GinName, GinStandNum, GinStandPositionNum) VALUES ('NULL', {port_num}, '{gin_name}' ,{gin_stand_num}, 1);"

        localSQL.sql_insert(cnx, insert_query)
        return True

    except (Exception) as err:
        # Create error message:
        err_msg = f"Encountered error in, File: nodes_connected_uplink, Function: add_node func. \nError: {err}"
        # Write error to error log:
        write_error_log(err_msg=err_msg)
        print(err_msg)
        return False

    finally:
        localSQL.sql_closeConnection(cnx)



def update_node(node_params: json) -> bool:
    """
        Function Description:
            - Called from anvil_uplink_router.update_node_connection
            - Updates a nodes parameters in CamNodes_Info table

        Input Args:
            - node_params (json(dict)): parameters to update in database
            - node_params = json.dumps({
              'gin_stand': self.gin_name_drop_down.selected_value,
              'gin_stand_num': self.gin_stand_drop_down.selected_value,
              'port_num': port_num,
            })

        Output Args:
            - Bool: Indicates if successful update of database
    """
    """Update node entries in the database"""

    # unpack json to python dict:
    node_params = json.loads(node_params)

    # Unpack dictionary
    gin_name = node_params.get('gin_stand')
    gin_stand_num = node_params.get('gin_stand_num')
    port_num = node_params.get('port_num')

    # Add node to datatable:
    try:
        # Setup connection to table:
        cnx = localSQL.sql_connect()

        print(f"Updating Node {port_num} in database..")

        update_query = f"UPDATE CamNodes_Info SET GinName = '{gin_name}', GinStandNum = {gin_stand_num} WHERE port = {port_num};"

        localSQL.sql_update(cnx, update_query)

        return True
    except (Exception) as err:
        # Create error message:
        err_msg = f"Encountered error in, File: nodes_connected_uplink, Function: update_node func. \nError: {err}"
        # Write error to error log:
        write_error_log(err_msg=err_msg)
        print(err_msg)
        return False

    finally:
        localSQL.sql_closeConnection(cnx)



def remove_node(node_params: json) -> bool:
    """
        Function Description:
            - Called from anvil_uplink_router.remove_node_connection
            - Removes a node from the table `CamNodes_Info`

        Input Args:
            - node_params (json(dict)): Node parameters
            - node_params = json.dumps({
                'port_num': row_content[0].text,
                'gin_name': row_content[1].text,
                'gin_stand_num': row_content[2].text,
            })

        Output Args:
            - (bool): Indicates if succesfully removed info on node from table
    """

    node_params = json.loads(node_params)

    # Get node_params values:
    gin_name = node_params.get('gin_name')
    gin_stand_num = node_params.get('gin_stand_num')
    port_num = node_params.get('port_num')

    # Add node to datatable:
    try:
        # Setup connection to table:
        cnx = localSQL.sql_connect()

        print(f"Removing Node {port_num} to database..")
        delete_query = f"DELETE FROM CamNodes_Info WHERE port = {port_num} AND GinName = '{gin_name}' AND GinStandNum = {gin_stand_num};"

        localSQL.sql_update(cnx, delete_query)
        return True
    except (Exception) as err:
        # Create error message:
        err_msg = f"Encountered error in, File: nodes_connected_uplink, Function: remove_node func. \nError: {err}"
        # Write error to error log:
        write_error_log(err_msg=err_msg)
        print(err_msg)
        return False

    finally:
        localSQL.sql_closeConnection(cnx)



def get_all_gins() -> list:
    """
        Function Description:
            - Called from nodes_connected_uplink.check_if_all_gins_accessible
            - Gets the names of all gins stored in the `gins` datatable

        Input Args:
            - None

        Output Args:
            - all_gins (list): List of all the gins with pides / visn systems
    """
    """ returns a list of all gins with VISN equipment"""

    try:
        # Connect to datatable
        cnx = localSQL.sql_connect()

        # Setup select query
        select_query = f"SELECT gin_name FROM gins"

        result = localSQL.sql_select(cnx, select_query)

        # Should enter here:
        if result:
            # Format result
            all_gins = []
            for gin in result:
                single_gin = gin[0]
                all_gins.append(single_gin)

            print(f"all gins: {all_gins}")
            return all_gins
        else:
            # This is a serious error if this is called...
            print("No gins Found!!")

            return None
        
    except(Exception) as err:
        # Create error message:
        err_msg = f"Encountered error in, File: nodes_connected_uplink, Function: get_all_gins func. \nError: {err}"
        # Write error to error log:
        write_error_log(err_msg=err_msg)
        print(err_msg)
        return False

    finally:
        localSQL.sql_closeConnection(cnx)


def compare_lists(list1: list, list2: list) -> bool:
    """
        Function Description:
            - Called from nodes_connected_uplink.check_if_all_gins_accessible
            - Compares two lists. if both lists are the same, return True else False

        Input Args:
            - list1 (list): list to be compared to
            - list2 (list): list doing the comparing

        Output Args:
            - bool: Indicates if both lists are the same (T/F)
    """

    # Get all common elements between the two lists
    common_elements = set(list1).intersection(list2)

    # If every element in list1 is in list2, the lengths will be equal:
    return len(common_elements) == len(list1)

def check_if_all_gins_accessible(gins_accessible: json) -> bool:
    """
        Function Description:
            - Called from anvil_uplink_router.check_if_all_gins_accessible
            - Checks if the user has access to all gins stored in the `gins` datatable
            - Determines if user has the option to view the 'all gins' and 'unassigned' drop downs.

        Input Args:
            - gins_accessible (json(list)): List of gin names user can access

        Output Args:
            - BOOL: Indicates if user has access to all gins (T/F)
 
    """
    # Convert to python list:
    gins_accessible = json.loads(gins_accessible)

    # Get all active gins:
    all_gins = get_all_gins()

    # compare gins_accessible to all_gins
    result_bool = compare_lists(all_gins, gins_accessible)

    if result_bool:
        print("User has access to all gins")
        return True
    else:
        print("User does not have access to all gins")
        return False

